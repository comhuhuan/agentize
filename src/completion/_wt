#compdef wt

# Zsh completion for wt (Git Worktree Helper)
# This completion file provides interactive command-line hints for wt subcommands and flags

_wt() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    # Try to use wt --complete if available, fallback to static lists
    local -a commands
    if (( $+commands[wt] )); then
        # Dynamically fetch commands from wt --complete
        commands=( ${(f)"$(wt --complete commands 2>/dev/null)"} )
    fi

    # Fallback to static command list if dynamic fetch failed
    if (( ${#commands} == 0 )); then
        commands=(
            'common:Print git common directory (bare repo path)'
            'init:Initialize worktree environment (creates trees/main)'
            'goto:Change directory to worktree target'
            'spawn:Create worktree for an issue'
            'list:List all worktrees'
            'remove:Remove worktree and delete branch'
            'prune:Clean up stale worktree metadata'
            'purge:Remove worktrees for closed GitHub issues'
            'help:Display help message'
        )
    else
        # Add descriptions to dynamically fetched commands
        local -a commands_with_desc
        for cmd in $commands; do
            case $cmd in
                common) commands_with_desc+=('common:Print git common directory (bare repo path)') ;;
                init) commands_with_desc+=('init:Initialize worktree environment (creates trees/main)') ;;
                goto) commands_with_desc+=('goto:Change directory to worktree target') ;;
                spawn) commands_with_desc+=('spawn:Create worktree for an issue') ;;
                list) commands_with_desc+=('list:List all worktrees') ;;
                remove) commands_with_desc+=('remove:Remove worktree and delete branch') ;;
                prune) commands_with_desc+=('prune:Clean up stale worktree metadata') ;;
                purge) commands_with_desc+=('purge:Remove worktrees for closed GitHub issues') ;;
                help) commands_with_desc+=('help:Display help message') ;;
            esac
        done
        commands=( $commands_with_desc )
    fi

    _arguments -C \
        '1: :->command' \
        '*::arg:->args'

    case $state in
        command)
            _describe -t commands 'wt commands' commands
            ;;
        args)
            case $line[1] in
                goto)
                    _wt_goto
                    ;;
                spawn)
                    _wt_spawn
                    ;;
                remove)
                    _wt_remove
                    ;;
            esac
            ;;
    esac
}

# Completion for 'wt goto' subcommand
_wt_goto() {
    local -a goto_targets

    # Try dynamic fetch first
    if (( $+commands[wt] )); then
        goto_targets=( ${(f)"$(wt --complete goto-targets 2>/dev/null)"} )
    fi

    # Fallback to main only
    if (( ${#goto_targets} == 0 )); then
        goto_targets=( 'main' )
    fi

    _arguments \
        "1:target:(${goto_targets})"
}

# Completion for 'wt spawn' subcommand
_wt_spawn() {
    local -a spawn_flags
    local -a option_specs

    # Try dynamic fetch first
    if (( $+commands[wt] )); then
        spawn_flags=( ${(f)"$(wt --complete spawn-flags 2>/dev/null)"} )
    fi

    # Fallback to static flags
    if (( ${#spawn_flags} == 0 )); then
        spawn_flags=( '--yolo' '--no-agent' )
    fi

    # Build option specs from flags
    for flag in $spawn_flags; do
        case $flag in
            --yolo)
                option_specs+=('--yolo[Skip permission prompts (use in containers/VMs)]')
                ;;
            --no-agent)
                option_specs+=('--no-agent[Skip automatic Claude invocation]')
                ;;
            *)
                # Unknown flag, pass through without description
                option_specs+=("$flag")
                ;;
        esac
    done

    _arguments \
        '1:issue number:' \
        $option_specs
}

# Completion for 'wt remove' subcommand
_wt_remove() {
    local -a remove_flags
    local -a option_specs

    # Try dynamic fetch first
    if (( $+commands[wt] )); then
        remove_flags=( ${(f)"$(wt --complete remove-flags 2>/dev/null)"} )
    fi

    # Fallback to static flags
    if (( ${#remove_flags} == 0 )); then
        remove_flags=( '--delete-branch' '-D' '--force' )
    fi

    # Build option specs from flags
    for flag in $remove_flags; do
        case $flag in
            --delete-branch)
                option_specs+=('--delete-branch[Delete branch even if unmerged]')
                ;;
            -D)
                option_specs+=('-D[Alias for --delete-branch (legacy)]')
                ;;
            --force)
                option_specs+=('--force[Alias for --delete-branch (legacy)]')
                ;;
            *)
                # Unknown flag, pass through without description
                option_specs+=("$flag")
                ;;
        esac
    done

    _arguments \
        '1:issue number:' \
        $option_specs
}

_wt "$@"
