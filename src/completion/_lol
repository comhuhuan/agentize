#compdef lol

# Zsh completion for lol (AI-powered SDK CLI)
# Provides interactive command-line hints for lol subcommands and flags
# Supports: upgrade, use-branch, version, project, usage, serve, claude-clean, plan, impl, simp

_lol() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    # Try to use lol --complete if available, fallback to static lists
    local -a commands
    if (( $+commands[lol] )); then
        # Dynamically fetch commands from lol --complete
        commands=( ${(f)"$(lol --complete commands 2>/dev/null)"} )
    fi

    # Fallback to static command list if dynamic fetch failed
    if (( ${#commands} == 0 )); then
        commands=(
            'upgrade:Upgrade agentize installation'
            'use-branch:Switch to a remote development branch'
            'version:Display version information'
            'project:Manage GitHub Projects v2 integration'
            'usage:Report Claude Code token usage statistics'
            'serve:Start polling server for GitHub Projects automation'
            'claude-clean:Remove stale Claude config entries'
            'plan:Run multi-agent debate pipeline'
            'impl:Automate the issue-to-implementation loop using wt + acw'
            'simp:Simplify code without changing semantics'
        )
    else
        # Add descriptions to dynamically fetched commands
        local -a commands_with_desc
        for cmd in $commands; do
            case $cmd in
                upgrade) commands_with_desc+=('upgrade:Upgrade agentize installation') ;;
                use-branch) commands_with_desc+=('use-branch:Switch to a remote development branch') ;;
                version) commands_with_desc+=('version:Display version information') ;;
                project) commands_with_desc+=('project:Manage GitHub Projects v2 integration') ;;
                usage) commands_with_desc+=('usage:Report Claude Code token usage statistics') ;;
                serve) commands_with_desc+=('serve:Start polling server for GitHub Projects automation') ;;
                claude-clean) commands_with_desc+=('claude-clean:Remove stale Claude config entries') ;;
                plan) commands_with_desc+=('plan:Run multi-agent debate pipeline') ;;
                impl) commands_with_desc+=('impl:Automate the issue-to-implementation loop using wt + acw') ;;
                simp) commands_with_desc+=('simp:Simplify code without changing semantics') ;;
            esac
        done
        commands=( $commands_with_desc )
    fi

    _arguments -C \
        '1: :->command' \
        '*::arg:->args'

    case $state in
        command)
            _describe -t commands 'lol commands' commands
            ;;
        args)
            case $line[1] in
                claude-clean)
                    _lol_claude_clean
                    ;;
                plan)
                    _lol_plan
                    ;;
                impl)
                    _lol_impl
                    ;;
                simp)
                    _lol_simp
                    ;;
                upgrade)
                    _lol_upgrade
                    ;;
                use-branch)
                    _lol_use_branch
                    ;;
                project)
                    _lol_project
                    ;;
                serve)
                    _lol_serve
                    ;;
                usage)
                    _lol_usage
                    ;;
                version)
                    _lol_version
                    ;;
            esac
            ;;
    esac
}

# Completion for 'lol plan' subcommand
_lol_plan() {
    _arguments -s \
        '--dry-run[Skip GitHub issue creation; use timestamp-based artifacts]' \
        '--verbose[Print detailed stage logs]' \
        '--editor[Open $EDITOR to compose feature description]' \
        '--refine[Refine an existing plan issue]:issue-number:' \
        ':feature description:'
}

# Completion for 'lol impl' subcommand
_lol_impl() {
    local -a impl_flags impl_flags_with_desc

    # Try dynamic fetch first
    if (( $+commands[lol] )); then
        impl_flags=( ${(f)"$(lol --complete impl-flags 2>/dev/null)"} )
    fi

    # Fallback to static flags
    if (( ${#impl_flags} == 0 )); then
        impl_flags=( '--backend' '--max-iterations' '--yolo' )
    fi

    for flag in $impl_flags; do
        case $flag in
            --backend) impl_flags_with_desc+=( '--backend[Backend in provider:model form]:backend:' ) ;;
            --max-iterations) impl_flags_with_desc+=( '--max-iterations[Maximum iterations before giving up]:number:' ) ;;
            --yolo) impl_flags_with_desc+=( '--yolo[Enable dangerous mode for provider CLI]' ) ;;
            *) impl_flags_with_desc+=( "$flag" ) ;;
        esac
    done

    _arguments \
        ${impl_flags_with_desc[@]} \
        ':issue-number:'
}

# Completion for 'lol simp' subcommand
_lol_simp() {
    local -a simp_flags simp_flags_with_desc

    # Try dynamic fetch first
    if (( $+commands[lol] )); then
        simp_flags=( ${(f)"$(lol --complete simp-flags 2>/dev/null)"} )
    fi

    # Fallback to static flags
    if (( ${#simp_flags} == 0 )); then
        simp_flags=( '--editor' '--focus' '--issue' )
    fi

    for flag in $simp_flags; do
        case $flag in
            --editor) simp_flags_with_desc+=( '--editor[Open $EDITOR to compose focus description]' ) ;;
            --focus) simp_flags_with_desc+=( '--focus[Focus description to guide simplification]:description:' ) ;;
            --issue) simp_flags_with_desc+=( '--issue[Publish report to issue when approved]:issue-number:' ) ;;
            *) simp_flags_with_desc+=( "$flag" ) ;;
        esac
    done

    _arguments \
        ${simp_flags_with_desc[@]} \
        '::file:_files'
}

# Completion for 'lol upgrade' subcommand
_lol_upgrade() {
    local -a upgrade_flags upgrade_flags_with_desc

    # Try dynamic fetch first
    if (( $+commands[lol] )); then
        upgrade_flags=( ${(f)"$(lol --complete upgrade-flags 2>/dev/null)"} )
    fi

    # Fallback to static flags
    if (( ${#upgrade_flags} == 0 )); then
        upgrade_flags=( '--keep-branch' )
    fi

    for flag in $upgrade_flags; do
        case $flag in
            --keep-branch) upgrade_flags_with_desc+=( '--keep-branch[Keep current branch and pull its upstream]' ) ;;
            *) upgrade_flags_with_desc+=( "$flag" ) ;;
        esac
    done

    _arguments \
        ${upgrade_flags_with_desc[@]}
}

# Completion for 'lol version' subcommand
_lol_version() {
    # No flags or arguments for version command
    return 0
}

# Completion for 'lol project' subcommand
_lol_project() {
    local -a project_modes project_create_flags project_automation_flags

    # Try dynamic fetch first
    if (( $+commands[lol] )); then
        project_modes=( ${(f)"$(lol --complete project-modes 2>/dev/null)"} )
        project_create_flags=( ${(f)"$(lol --complete project-create-flags 2>/dev/null)"} )
        project_automation_flags=( ${(f)"$(lol --complete project-automation-flags 2>/dev/null)"} )
    fi

    # Fallback to static flags
    if (( ${#project_modes} == 0 )); then
        project_modes=( '--create' '--associate' '--automation' )
    fi
    if (( ${#project_create_flags} == 0 )); then
        project_create_flags=( '--org' '--title' )
    fi
    if (( ${#project_automation_flags} == 0 )); then
        project_automation_flags=( '--write' )
    fi

    _arguments \
        '--create[Create new GitHub Projects v2 board]' \
        '--associate[Associate existing project board]:org/id:' \
        '--automation[Generate automation workflow template]' \
        '--org[GitHub organization]:organization:' \
        '--title[Project title]:title:' \
        '--write[Write automation template to file]:path:_files'
}

# Completion for 'lol usage' subcommand
_lol_usage() {
    local -a usage_flags

    # Try dynamic fetch first
    if (( $+commands[lol] )); then
        usage_flags=( ${(f)"$(lol --complete usage-flags 2>/dev/null)"} )
    fi

    # Fallback to static flags
    if (( ${#usage_flags} == 0 )); then
        usage_flags=( '--today' '--week' '--cache' '--cost' )
    fi

    _arguments \
        '--today[Show usage by hour for the last 24 hours]' \
        '--week[Show usage by day for the last 7 days]' \
        '--cache[Include cache token statistics]' \
        '--cost[Show cost estimate]'
}

# Completion for 'lol claude-clean' subcommand
_lol_claude_clean() {
    local -a claude_clean_flags

    # Try dynamic fetch first
    if (( $+commands[lol] )); then
        claude_clean_flags=( ${(f)"$(lol --complete claude-clean-flags 2>/dev/null)"} )
    fi

    # Fallback to static flags
    if (( ${#claude_clean_flags} == 0 )); then
        claude_clean_flags=( '--dry-run' )
    fi

    _arguments \
        '--dry-run[Preview changes without modifying ~/.claude.json]'
}

# Completion for 'lol serve' subcommand
# Note: lol serve no longer accepts CLI flags
# Configuration is YAML-only: server.period and server.num_workers in .agentize.local.yaml
_lol_serve() {
    # No CLI flags - show message about YAML configuration
    _message "Configure server.period and server.num_workers in .agentize.local.yaml"
}

# Completion for 'lol use-branch' subcommand
_lol_use_branch() {
    _arguments \
        ':remote/branch:'
}

_lol "$@"
